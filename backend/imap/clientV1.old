// Package imap implements a provider for imap servers.
package imap

import (
	"crypto/tls"
	"fmt"
	"io"
	"strings"
	"time"

	"github.com/rclone/rclone/fs"

	"github.com/emersion/go-imap"
	"github.com/emersion/go-imap/client"
)

type mailclient1 struct {
	conn      *client.Client
	f         *Fs
	delimiter string
	mailboxes []string
}

type mailreader1 struct {
	reader io.Reader
	size   int64
}

func newMailClientV1(f *Fs) (*mailclient1, error) {
	cli := &mailclient1{
		conn:      nil,
		f:         f,
		mailboxes: []string{},
	}
	// try and login
	err := cli.login()
	if err != nil {
		return nil, err
	}
	return cli, nil
}

func newMailReaderV1(reader io.Reader, size int64) *mailreader1 {
	return &mailreader1{
		reader: reader,
		size:   size,
	}
}

func (r *mailreader1) Read(b []byte) (n int, err error) {
	return r.reader.Read(b)
}

func (r *mailreader1) Len() int {
	return int(r.size)
}

func (m *mailclient1) dirToMailbox(dir string) string {
	return strings.ReplaceAll(strings.Trim(dir, "/"), "/", m.delimiter)
}

func (m *mailclient1) mailboxToDir(mailbox string) string {
	return strings.ReplaceAll(mailbox, m.delimiter, "/")
}

func (m *mailclient1) login() error {
	var err error
	//
	address := fmt.Sprintf("%s:%d", m.f.host, m.f.port)
	// create options and options.TLSConfig()
	tlsConfig := new(tls.Config)
	// do we check for valid certificate
	tlsConfig.ServerName = m.f.host
	if m.f.skipVerify {
		tlsConfig.InsecureSkipVerify = true
	}
	// create client
	fs.Debugf(nil, "Connecting to %s", address)
	if m.f.security == securityStartTLS {
		m.conn, err = client.Dial(address)
		if err != nil {
			return fmt.Errorf("failed to dial IMAP server: %w", err)
		}
		// create STARTTLS client
		err = m.conn.StartTLS(tlsConfig)
		if err != nil {
			defer m.Logout()
			return err
		}
	} else if m.f.security == securityTLS {
		m.conn, err = client.DialTLS(address, nil)
		if err != nil {
			return fmt.Errorf("failed to dial IMAP server: %w", err)
		}
	} else if m.f.security == securityNone {
		m.conn, err = client.Dial(address)
		if err != nil {
			return fmt.Errorf("failed to dial IMAP server: %w", err)
		}
	}
	// connected ok, now login
	err = m.conn.Login(m.f.user, m.f.pass)
	if err != nil {
		defer m.Logout()
		return fmt.Errorf("failed to login: %w", err)
	}
	// get list of mailboxes
	err = m.RefreshMailboxes()
	if err != nil {
		defer m.Logout()
		return err
	}
	//
	return nil
}

func (m *mailclient1) Logout() {
	if m.conn != nil {
		_ = m.conn.Logout()
	}
	//
	m.conn = nil
}

func (m *mailclient1) RefreshMailboxes() error {
	if m.conn == nil {
		return fmt.Errorf("failed to get mailboxes : not connected")
	}
	// get mailboxes
	mailboxes := make(chan *imap.MailboxInfo, 10)
	done := make(chan error, 1)
	go func() {
		done <- m.conn.List("", "*", mailboxes)
	}()
	m.mailboxes = []string{}
	for mbox := range mailboxes {
		m.delimiter = mbox.Delimiter
		m.mailboxes = append(m.mailboxes, mbox.Name)
	}
	if err := <-done; err != nil {
		defer m.Logout()
		return fmt.Errorf("failed to get mailboxes: %v", err)
	}
	return nil
}

func (m *mailclient1) ListMailboxes(dir string) ([]string, error) {
	if m.conn == nil {
		return nil, fmt.Errorf("failed to list mailboxes : not connected")
	}
	list := []string{}
	for _, curr := range m.mailboxes {
		list = append(list, m.mailboxToDir(curr))
	}
	return getMatches(dir, list), nil
}

func (m *mailclient1) HasMailbox(dir string) bool {
	if m.conn == nil {
		return false
	}
	for _, curr := range m.mailboxes {
		if m.dirToMailbox(dir) == curr {
			return true
		}
	}
	return false
}

func (m *mailclient1) RenameMailbox(from string, to string) error {
	if m.conn == nil {
		return fmt.Errorf("failed to rename mailbox %s: not connected", from)
	}
	fs.Debugf(nil, "Rename mailbox %s to %s", from, to)
	err := m.conn.Rename(m.dirToMailbox(from), m.dirToMailbox(to))
	if err != nil {
		return fmt.Errorf("failed to rename mailbox %s: %w", from, err)
	}
	return m.RefreshMailboxes()
}

func (m *mailclient1) CreateMailbox(name string) error {
	if m.conn == nil {
		return fmt.Errorf("failed to create mailbox %s: not connected", name)
	}
	fs.Debugf(nil, "Create mailbox %s", name)
	err := m.conn.Create(m.dirToMailbox(name))
	if err != nil {
		return fmt.Errorf("failed to create mailbox %s: %w", name, err)
	}
	return m.RefreshMailboxes()
}

func (m *mailclient1) DeleteMailbox(name string) error {
	if m.conn == nil {
		return fmt.Errorf("failed to delete mailbox %s: not connected", name)
	} else if name == "" {
		return fmt.Errorf("cant remove root")
	}
	// select mailbox, readonly
	selectedMbox, err := m.conn.Select(m.dirToMailbox(name), true)
	if err != nil {
		return fs.ErrorDirNotFound
	}
	if selectedMbox.Messages != 0 {
		return fmt.Errorf("mailbox not empty, has %d messages", selectedMbox.Messages)
	}
	//
	fs.Debugf(nil, "Delete mailbox %s", name)
	err = m.conn.Delete(m.dirToMailbox(name))
	if err != nil {
		return fmt.Errorf("failed to delete mailbox %s: %w", name, err)
	}
	return m.RefreshMailboxes()
}

func (m *mailclient1) ExpungeMailbox(mailbox string) error {
	if m.conn == nil {
		return fmt.Errorf("failed to expunge mailbox %s: not connected", mailbox)
	}
	// select mailbox, writable
	_, err := m.conn.Select(m.dirToMailbox(mailbox), false)
	if err != nil {
		return fs.ErrorDirNotFound
	}
	// expunge
	fs.Debugf(nil, "Expunge mailbox: %s", mailbox)
	err = m.conn.Expunge(nil)
	if err != nil {
		return fmt.Errorf("failed to expunge mailbox: %w", err)
	}
	//
	return nil
}

func (m *mailclient1) Save(mailbox string, date time.Time, size int64, reader io.Reader, flags []string) (err error) {
	if m.conn == nil {
		return fmt.Errorf("failed to save message to mailbox %s: not connected", mailbox)
	}
	fs.Debugf(nil, "Append message to mailbox %s", mailbox)
	err = m.conn.Append(m.dirToMailbox(mailbox), flags, date, newMailReaderV1(reader, size))
	if err != nil {
		return fmt.Errorf("failed to save message to mailbox %s: %w", mailbox, err)
	}
	return nil
}

func (m *mailclient1) SetFlags(mailbox string,ids  []uint32,flags ...string) error {
	if m.conn == nil {
		return fmt.Errorf("failed to sert message flags: not connected")
	}
	// select mailbox, writable
	_, err := m.conn.Select(m.dirToMailbox(mailbox), false)
	if err != nil {
		return fs.ErrorDirNotFound
	}
        seqset := new(imap.SeqSet)
	seqset.AddNum(ids...)
	// convert flags to interfaces
	flagInterfaces := make([]interface{}, len(flags))
	for i, v := range flags {
		flagInterfaces[i] = v
	}
	// Mark messages as deleted
	item := imap.FormatFlagsOp(imap.AddFlags, true)
	fs.Debugf(nil, "Set flags for messages with ID [%s]: %s", seqset, strings.Fields(strings.Trim(fmt.Sprint(flags), "[]")))
	err = m.conn.Store(seqset, item, flagInterfaces, nil)
	if err != nil {
		return fmt.Errorf("failed to set flags: %w", err)
	}
	//
	return nil
}

func (m *mailclient1) Search(mailbox string,since,before time.Time,larger,smaller uint32) (seqNums []uint32, err error) {
	if m.conn == nil {
		return nil, fmt.Errorf("failed to search messages : not connected")
	}
	// select mailbox, readonly
	selectedMbox, err := m.conn.Select(m.dirToMailbox(mailbox), true)
	if err != nil {
		return nil, fs.ErrorDirNotFound
	}
	if selectedMbox.Messages == 0 {
		return []uint32{}, nil
	}
        // init criteria for search
        criteria := imap.NewSearchCriteria()
        // include messages within date range
        criteria.Since = since
        criteria.Before = before
        // include messages with size between size-50 and size+50
        criteria.Larger = larger
        criteria.Smaller = smaller
	//
	ids, err := m.conn.Search(criteria)
	if err != nil {
		return nil, fmt.Errorf("failed to search messages : %w", err)
	}
	return ids, err
}

func (m *mailclient1) ForEach(mailbox string, action func(uint32,time.Time,uint32,[]string,io.Reader)) error {
        var reader io.Reader
	//
        if m.conn == nil {
                return fmt.Errorf("failed to fetch messages : not connected")
        }
        // select mailbox, readonly
        selectedMbox, err := m.conn.Select(m.dirToMailbox(mailbox), true)
        if err != nil {
                return fs.ErrorDirNotFound
        }
        if selectedMbox.Messages == 0 {
                return nil
        }
	//
        items := []imap.FetchItem{imap.FetchFlags, imap.FetchInternalDate, imap.FetchRFC822Size, imap.FetchItem("BODY.PEEK[]")}
        seqset := new(imap.SeqSet)
	seqset.AddRange(1, selectedMbox.Messages)
        //
        messages := make(chan *imap.Message, 10)
        done := make(chan error, 1)
        // fetch messages on background
        go func() {
                done <- m.conn.Fetch(seqset, items, messages)
        }()
        // process messages
        for msg := range messages {
                if action != nil {
		        // get body io.Reader (should be first value in msg.Body)
		        for _, curr := range msg.Body { 
				reader = curr
		                break
		        }
			//
                        action(msg.SeqNum,msg.InternalDate,msg.Size,msg.Flags,reader)
                }
        }
        // check for error
        if err := <-done; err != nil {
                return fmt.Errorf("failed to fetch messages : %w", err)
        }
        return nil
}

func (m *mailclient1) ForEachId(mailbox string, ids []uint32, action func(uint32,time.Time,uint32,[]string,io.Reader)) error {
        var reader io.Reader
	//
        if m.conn == nil {
                return fmt.Errorf("failed to fetch messages : not connected")
        }
        // select mailbox, readonly
        selectedMbox, err := m.conn.Select(m.dirToMailbox(mailbox), true)
        if err != nil {
                return fs.ErrorDirNotFound
        }
        if selectedMbox.Messages == 0 {
                return nil
        }
	//
        items := []imap.FetchItem{imap.FetchFlags, imap.FetchInternalDate, imap.FetchRFC822Size, imap.FetchItem("BODY.PEEK[]")}
        seqset := new(imap.SeqSet)
	seqset.AddNum(ids...)
        //
        messages := make(chan *imap.Message, 10)
        done := make(chan error, 1)
        // fetch messages on background
        go func() {
                done <- m.conn.Fetch(seqset, items, messages)
        }()
        // process messages
        for msg := range messages {
                if action != nil {
		        // get body io.Reader (should be first value in msg.Body)
		        for _, curr := range msg.Body { 
				reader = curr
		                break
		        }
			//
                        action(msg.SeqNum,msg.InternalDate,msg.Size,msg.Flags,reader)
                }
        }
        // check for error
        if err := <-done; err != nil {
                return fmt.Errorf("failed to fetch messages : %w", err)
        }
        return nil
}
